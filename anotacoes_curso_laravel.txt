Curso PHP

- php artisan serve
- php artisan list
- npm run dev 
- php artisan downs
___________________________________________________________________
Rotas - Goroutes laravel

- São caminhos que determinamos dentro do nosso sistema
- A organização das rotas do laravel 
 --- API
 --- Chanenels
 --- Console
 --- Web

___________________________________________________________________
Super getão - implementando as rotas princiapl, sobre-nos e contato

- implemente dentro de routes/web.app as novas rotas.

Route::get('/sobre-nos', function () {
    return 'Sobre-nós';
});
Route::get('/contato', function () {
    return 'Contato';
});

- Para acessalas é simples ative seu serve e na url acrescente 
/contato e depois /sobre-nos;
___________________________________________________________________
Controller

- É responsavel por agrupar a logica doque deve ser feito a cada 
ação;
- Essa sepração é ideal para uma melhor arquitetura e do seu codigo
e para deixar as rotas apenas com os metodos http;
_________________________________________________________________
Implementando os controladores

- Sendo o PrincipalController() ,SobreNosController() e ContatoController();
- php artisan make:Controller PrincipalController
- Em App/controllers/ abra seu arquivo craido
- Adicione um metodo qualquer no meu caso adicionei este

public function principal(){
        echo"Olá, seja bem vindo ao curso";
    }
- Modificando as rotas para o laravel 11 ficou assim agora puxando
os metodos.

Route::get('/',[PrincipalController::class,'principal']);
Route::get('/contato',[ContatoController::class,'contato']);
Route::get('/sobre-nos',[SobreNosController::class,'sobreNos']);

___________________________________________________________________
Visualizações (views)- Introdução.

- Temos o metodo tradicional que é o html e temos o metodo moderno 
com API;
- e por enquando vamos ver o medoto com views no caso o metodo 
convencional;
___________________________________________________________________
Super Gestão - implementando as visualizações principal, sobre-nos 
e contato

- As views são onde armazenamos todo o HTML do nosso código;
- Crie dentro de resources/views/ um diretory site e outro app;
- Em site crie uma arquivo principal.blade.php ,um para sobre-nos e
outro para contato;
- Dentro da view coloque um titulo com <h3>Principal (view)</h3>;
- Volte ao controller do sobre-nós e coloque no metodo;


 public function principal(){
       return view('site.principal');
    }


- Execute com php artisan serve;
- Perceba que apenas alterou a forma de passar a resposta para a view;
- Então até agora estamos funcionando assim -- Router -- vai ate o 
Controller e vê em qual método ele vai participar e retorna pra view
uma resposta;
___________________________________________________________________
Enviando parâmetros

- Os parâmentros são fundamentais dentro da lógica de negócio;
- em web.php crie uma nova rota.
- para conseguirmos passar parâmetro dentro das rotas basta adicionar
chaves e claro o parâmetro;


Route::get('/contato/{nome}', function(){
    echo"estamos aqui";
});

- Para agora passar uma resposa a function ou seja para o  callback
temos que passar informações para ele também, informação essa;
Route::get('/contato/{nome}', function(String $nome){
    echo"estamos aqui".$nome;
});


- Coloque para rodar no servidor php artisan serve;
- Quando na Url você adcionar a rota contato perecba que vai chamar
o contato padrão agora quando adicionado /contato/qualquerNome a 
framework entende que estamos chamando a rota contato com parametros 
e entrega na view uma outra resposta;
- Com isso podemos aumentar cada vez mais os parametros de uma rota;


 Route::get('/contato/{nome}/{z}/{a}', function(String $nome, String $z, String $a){
    echo"Estamos aqui: ". $nome, $z, $a;
});

___________________________________________________________________
Parâmetros opcionais e valores padrões

- No modo anterior todos os parâmetros informados na url eram 
obrigatórios agora vamos ver como resolver isso e deixar de forma 
opcional;
- Temos que adicionar um ponto de interrogação ao final do parametro
dentro da chave e colocar para ser recebido um valor caso não seja
exigido o parâmetro;

Route::get('/contato/{nome}/{z}/{a?}', function(String $nome, 
String $z, String $a = "mensagem nao enviada"){
    echo"Estamos aqui: ". $nome, $z, $a;
});

- Perceba que dentro do paramentro 'a' ele tem um ponto de 
interrogação e caso não seja passado nada ele retorna "mensagem 
nao enviada";
- Temos que tomar muito cuidado também com isso pois o laravel se
encontra limitado em deixar parâmetros opcionais pois, ele pode não
entender oque te responder e aparecer 404 - NotFound;
- O ideal é sempre deixar os parametros opcinais da direita para 
esquerda de modo em que ele não perca essa ordem;
___________________________________________________________________
Tratando parâmetros de rotas com expressões regulares

- Tratamento de parâmentos com expressões regulares, nada mais é que
vc passar uma regra de parâmetro para ser possivel acessar tal url;
- aqui apenas alterei o nome da veriavel para categoria_id para
melhor intendimento mesmo;

Route::get(
    '/contato/{nome}/{categoria_id}',
    function (
        String $nome = "desconhecido",
        int $categoria_id = 1
    ) {
        echo "Estamos aqui: " . $nome, $categoria_id;
    }
);

- Perceba que aqui para realizarmos essa regra atribuimos um valor 
para a variavel categoria_id de igual a 1;
- Desse modo quando testamos na nossa url o primeiro parametro que
para a desnvolvimento foi definido como nome, pode ser qualquer nome,
agora o categoria_id não;
- Realize o teste na sua url e troque o valor de 1 para outro 
qualquer e veja que é gerado um erro apenas quando colocamos um 
valor não número estilo string;
- Agora podemos também realizar uma validação um pouco mais 
inteligente no modo em que passamos uma regra para o parametro ou 
seja;

Route::get(
    '/contato/{nome}/{categoria_id}',
    function (
        String $nome = "desconhecido",
        int $categoria_id = 25
    ) {
        echo "Estamos aqui: " . $nome, $categoria_id;
    }
)->where('categoria_id', '[0-9]+');

- Aqui em Where estou informando que o parametro categoria_id vai 
funcionar de modo que ele só aceita número que sejam inteiros entre
zero e nove e tenha nó minimo um número sendo simbolizado isso 
pelo +;

Route::get(
    '/contato/{nome}/{categoria_id}',
    function (
        String $nome = "desconhecido",
        int $categoria_id = 25
    ) {
        echo "Estamos aqui: " . $nome, $categoria_id;
    }
)->where('categoria_id', '[0-9]+')->where('nome','[A-Za-z]+');


- Adicionando esse código ao final do parenteses estou determinado 
agora que os dois parametros tem regras, sendo assim o primeiro 
paramentro é sendo obrigado a ter qual letra de a ou z maiuscula
ou minuscula e sendo obrigao ter no minimo uma;

___________________________________________________________________
Super gestão - criando o menu de navegação

- Criamos na pagina principal.blade.php uma lista;

 <h3>Principal (view)</h3>
    <ul>
        <li><a href="/">Principal</a></li>
        <li><a href="/sobre-nos">Sobre Nós</a></li>
        <li><a href="/contato">Contato</a></li>
    </ul>

- Caso queira trabalhar com dois terminal no vscode é possivel;
- No terminal coloque php artisan route:list e será mostrado para 
você a lista de todas as rotas que vc criou;
___________________________________________________________________
Super Gestão - Implementando as rotas login, clientes, fornecedores
 e produtos

- crie 4 novas rotas para login, clientes, fornecedores, produtos;

___________________________________________________________________
Agrupando rotas

- O agrupamento de rotas serve para diversos motivos mas no nosso 
caso vamos cria-lo para conseguir separar a parte em todos acessam
para uma parte restrita.
- para isso criamos uma rota com prefix chamdo app onde agora na 
nossa url não vai ser mais digitado

http://127.0.0.1:8000/clientes

- e sim; 

http://127.0.0.1:8000/app/clientes

- assim ficou a estruturação da nossa rota de prefixo;

Route::prefix('/app')->group(function () {
    Route::get('/clientes', [ClientesController::class, 'clientes']);
    Route::get('/fornecedores', [FornecedoresController::class, 'fornecedores']);
    Route::get('/produtos', [ProdutosController::class, 'produtos']);
});

- Usando o comando php artisan route:list podemos ver também a 
mudança nas rotas que agora se encontram com /app;

___________________________________________________________________
Nomeando rotas

- É possível a gente nomear nossas rotas com o intuito de deixar 
cada vez mais otimizado nossa código, porém não podemos utilizar 
esse apelido na nossa url apenas na nossa aplicação;

Route::get('/', [PrincipalController::class, 'principal'])->name('site.index');
Route::get('/contato', [ContatoController::class, 'contato'])->name('site.contato');
Route::get('/sobre-nos', [SobreNosController::class, 'sobreNos'])->name('site.sobrenos');
Route::get('/login', [LoginController::class, 'login'])->name('site.login');

//app
Route::prefix('/app')->group(function () {
    Route::get('/clientes', [ClientesController::class, 'clientes'])->name('app.clientes');
    Route::get('/fornecedores', [FornecedoresController::class, 'fornecedores'])->name('app.fornecedores');
    Route::get('/produtos', [ProdutosController::class, 'produtos'])->name('app.produtos');
});

- Como realizamos essa nomeação temos que ir nas nossas view e 
também trocar;

<h3>Principal (view)</h3>
    <ul>
        <li><a href="{{route('site.index')}}">Principal</a></li>
        <li><a href="{{route('site.sobrenos')}}">Sobre Nós</a></li>
        <li><a href="{{route('site.contato')}}">Contato</a></li>
    </ul>

- Ficando assim as três views (principal, contato e sobre nós).
- Essa nomeação ajuda a não dependermos diretamente da nossa rota
uma vez que ela tem uma maior probabilidade de ser alterada;

___________________________________________________________________
Redirecionamento de rotas

- O redirecionamento ele é uma ferramenta muito boa pois dá a você
ainda mais controle de rotas que o  seu cliente vai acessar;
- Aqui criamos uma nova rota onde ela mostra apenas uma echo e logo
em baixo criamos outra rota com a o metodo redirect onde caso vc 
acesse a primeira rota, o metodo redirect rapidamente te enviara 
para a segunda rota mencionada; 


Route::get('/rota1', function(){
    echo"rota 1";
})->name('site.rota1');

Route::redirect('/babiono-doido', '/rota1');


- Realize o teste olhando sua url;
- Também podemos realizar essa função de redirecionamento do 
seguinte modo;


Route::get('/rota1', function(){
    echo"rota 1";
})->name('site.rota1');

Route::get('/rota2', function(){
    return redirect()->route('site.rota1');
})->name('site.rota2');

- Perceba que foi passado um return redirect chamando a o route pelo
nome dado a rota 2;

___________________________________________________________________
Rota de contingência (fallback)

- Um rota de contingência nada mais é que uma rota que será exibida 
para o cliente caso ele procure por alguma que o nosso sitema não 
esteja encontrando;


Route::fallback(function(){
    echo'A rota acessada não existe <a href="'.route('site.index').'">clique aqui</a> para voltar a página principal.';
});

___________________________________________________________________
Encaminhando parâmetros da rota para o controlador

- Criei uma nova rota e um novo controller, a principio colocamos
o nome de teste nessa rota acrescente dois parametros, aqui chamamos
de p1 e p2;

Route::get('/teste/{p1}/{p2}', [TesteController::class, 'teste'])->name('teste');

- Já no seu controller vamos colocar os parametros a serem 
recebidos;


public function teste(int $p1, int $p2){
        echo"A soma de $p1 + $p2 é igual:". ($p1+$p2);
    }

- Perceba que até aqui utilizamos muitos conhecimento adiquirido 
no curso como criar rotas, controller, parametros, nomear a rota 
etc;
- No controller adicionamos como parametro do metodo o p1 e p2 e 
também passamos um echo para realizar uma breve soma dos parametros
recebidos atraves da url;
___________________________________________________________________
Encaminhando parâmetros do controlador para visualização

- Como já apredemos como pegar um parametro da routa e passar para o
controller, agora vamos aprender a pegar do controller e jogar na 
view;
- Criaremos uma view em site com nome de teste;
- Dentro do controller criaremos um return view direcionando 
('site.teste');
- Lembre-se que quando for testar no servidor local passe dois 
parametros;
- Desse primeiro modo é com array associativo;


 public function teste(int $p1, int $p2){
       return view('site.teste', ['p1' =>$p1, 'p2'=>$p2]);
    }

- Desse segundo modo com compact percebe que não utilizamos 
a variavel e sim a string; 

  
 public function teste(int $p1, int $p2){
       return view('site.teste', compact('p1', 'p2'));
    }

- Porém em ambas as formas eu utilizo a variavel na view

<h1>
    <p>teste</p>
</h1>

<h1> P1 ={{$p1}}</h1>
<h1> P2 ={{$p2}}</h1>

- Desse terceiro modo com with vc vai adicionando with até atingir
todos os parametros;

public function teste(int $p1, int $p2)
    {
return view ('site.teste')->with('p1', $p1)->with('p2', $p2);
 }
_________________________________________________________
Sintaxe blade

- O blade é um motor de renderização de views responsavel
por interpretar o html e mostrar para cliente, além disso
ele possui um forte esquemas de templates;
- Ele consegue trabalhar com sintaxe pura do blade e do
php nas views;
_________________________________________________________
Blade - Incluíndo comentários e blocos PHP puros

- Para incluir comentario com blade {{--fuohejrfheruopeiur--}};
- Para abrir o php puro no blade utilizamos {{}} ou <?= ?>;
_________________________________________________________
Blade @if @else 

@dd($fornecedores)

@if (count($fornecedores) > 0 && count($fornecedores) < 10)
    <h3>Existem alguns fornecedores cadastrados</h3>
@elseif (count($fornecedores) >= 10)
    <h3>Existem muitos fornecedores cadastrados</h3>
@else
    <h3>Não existem fornecedores cadastrados</h3>
@endif

__________________________________________________________
Blade @unless

- O perador unless é o inverso if ele analisa algo negativo;

public function index(){
        $fornecedores = [
            0 => ['nome' => 'Fornecedor 1', 'status' => 'N']
        ];

        return view('app.fornecedor.index', compact('fornecedores'));
    }

- Perceba que dentro do metodo o array da favriavel esta tem duas
chaves sendo uma nome = fornecedor 1 e status = a n;
- Logo quando posto na view.

Fornecedor:{{$fornecedores[0]['nome']}};
<br>
Status:{{$fornecedores[0]['status']}};

- E simulado no servidor local aparece a info solicitada de 
fornecedor e status.
- Ao inves de utilizar isso tudo;


@if (!($fornecedores [0]['status'] == 'S'))
    Fornecedor inativo
@endif

- Podemos utilizar apenas @unless que ele realiza essa validação
inversa de if para você;


@unless (($fornecedores [0]['status'] == 'S'))
    Fornecedor inativo
@endunless
________________________________________________________________
Blade @isset

- O isset funciona para identificar se realmente um array exite;
- Caso você passe um metodo e não tenha colocado para retornar da
view vc pode utilizar o @isset desse modo no metodo; 


public function index(){
        $fornecedores = [
            0 => ['nome' => 'Fornecedor 1', 'status' => 'N']
        ];

        return view('app.fornecedor.index');
    }

- E assim na index;

 
@isset($fornecedores)
    Fornecedor:{{$fornecedores[0]['nome']}};
    <br>
    Status:{{$fornecedores[0]['status']}};
@endisset

- Quando for testado no servidor local repare que, não retornará 
nada pois essa info não foi selecionada para a view;
- Agora utilizando a vaiavel;


return view('app.fornecedor.index', compact('fornecedores'));

- No servidor retornara as infors solicitadas;
- Também podemos utilizar um isset dentro de outro isset;


@isset($fornecedores)
    Fornecedor:{{$fornecedores[0]['nome']}};
    <br>
    Status:{{$fornecedores[0]['status']}};
    <br>
    @isset($fornecedores[0]['cnpj'])
        CNPJ:{{$fornecedores[0]['cnpj']}};
    @endisset
@endisset
________________________________________________________________
Blade @empty

- Serve para saber se uma variavel esta ou não vazio;
- Retorna true para vazio;
- "", 0,0.0, '0', null, false, arra(), $var;
- Mude a atribuição do cnpj para qualquer uma das alternativas a 
cima e na index também ficando assim;


 $fornecedores = [
            0 => ['nome' => 'Fornecedor 1', 'status' => 'N', 'cnpj' => '0'],
            1 => ['nome' => 'Fornecedor 2', 'status' => 'S']
        ];

- Assim na index;


@isset($fornecedores)
    Fornecedor:{{$fornecedores[0]['nome']}};
    <br>
    Status:{{$fornecedores[0]['status']}};
    <br>
    @isset($fornecedores[0]['cnpj'])
        CNPJ:{{$fornecedores[0]['cnpj']}}
        @empty($fornecedores[0]['cnpj'])
            - Vazio
        @endempty
    @endisset
@endisset

________________________________________________________________
Extra - Operador condicional tenarnario do php

- Condicao ? se verdade : se falso:

 public function index(){
        $fornecedores = [
            0 => ['nome' => 'Fornecedor 1', 'status' => 'N', 'cnpj' => '005'],
            1 => ['nome' => 'Fornecedor 2', 'status' => 'S']
        ];

        //condicao ? se verdade : se falso:
       echo isset($fornecedores[0]['cnpj']) ? 'CNPJ informado' : 'CNPJ não informado';

        return view('app.fornecedor.index', compact('fornecedores'));
    }

- Note que se mudarmos dentro do echo no indice 0 para 1 teremos
a troca de cnpj informado ou não;
________________________________________________________________
Blade - Operador condicional de valor default (??)

- basicamente ele funciona para validar um variavel dessa forma;


public function index(){
        $fornecedores = [
            0 => ['nome' => 'Fornecedor 1', 'status' => 'N', 'cnpj' => '0'],
            1 => ['nome' => 'Fornecedor 2', 'status' => 'S']
        ];

        return view('app.fornecedor.index', compact('fornecedores'));
    }

- Se mudarmos no cnpj o valor que representa ele e deixar 'null'
com a view nessa condição vai retornar dado não foi preenchido;


 CNPJ:{{$fornecedores[1]['cnpj'] ?? 'Dano não foi preenchido'}};

- Pois ela entende que essa variavel não recebeu nenhum valor, 
ela também entende caso não seja definida o (isset);
________________________________________________________________
Balde - switch - case

- O switch nada mais é que uma porção de opções de que vc pode 
gerar, se ele for escolhido ele para ali, senão cai no default
ou segue normalmente;


public function index(){
        $fornecedores = [
            0 => ['nome' => 'Fornecedor 1', 'status' => 'N', 'cnpj' => '0', 'ddd'=>'11','telefone'=>'0000-0000'],
            1 => ['nome' => 'Fornecedor 2', 'status' => 'S', 'ddd'=>'85','telefone'=>'0000-0000'],
            2 => ['nome' => 'Fornecedor 2', 'status' => 'S', 'ddd'=>'32','telefone'=>'0000-0000']
        ];

        return view('app.fornecedor.index', compact('fornecedores'));
    }

- E no index fica;

@isset($fornecedores)
    Fornecedor:{{$fornecedores[2]['nome']}};
    <br>
    Status:{{$fornecedores[2]['status']}};
    <br>
    CNPJ:{{$fornecedores[2]['cnpj'] ?? 'Dado não foi preenchido'}};
    <br>
    Telefone:({{$fornecedores[2]['ddd'] ?? ''}}) {{
        $fornecedores[2]['telefone'] ?? '' }};

    @switch($fornecedores[2]['ddd'])
        @case('11')
            São Paulo -SP
            @break
        @case('32')
            Juiz de fora - MG
            @break
        @case('85')
            Fortaleza - CE
            @break
        @default
            Estado não identificado
    @endswitch
@endisset
________________________________________________________________
Blade - @for

@isset($fornecedores)
    @for ($i=0; isset($fornecedores[$i]); $i++)
        Fornecedor:{{$fornecedores[$i]['nome']}};
        <br>
        Status:{{$fornecedores[$i]['status']}};
        <br>
        CNPJ:{{$fornecedores[$i]['cnpj'] ?? 'Dado não foi preenchido'}};
        <br>
        Telefone:({{$fornecedores[$i]['ddd'] ?? ''}}) {{
            $fornecedores[$i]['telefone'] ?? '' }};
        <hr>
        @endfor
@endisset
________________________________________________________________
Blade - @while

- É uma função simples que funciona de modo que em quanto vc não 
terminal uma tarefa, ou enquanto for verdadeiro, ou enquanto for
falso isso vai continuar;


@isset($fornecedores)
    @php
        $i = 0
    @endphp
   @while (isset($fornecedores[$i]))
        Fornecedor:{{$fornecedores[$i]['nome']}};
        <br>
        Status:{{$fornecedores[$i]['status']}};
        <br>
        CNPJ:{{$fornecedores[$i]['cnpj'] ?? 'Dado não foi preenchido'}};
        <br>
        Telefone:({{$fornecedores[$i]['ddd'] ?? ''}}) {{
            $fornecedores[$i]['telefone'] ?? '' }};
        @php
            $i++
        @endphp
    @endwhile
@endisset
________________________________________________________________
Blade - @foreach

@isset($fornecedores)
    @foreach ($fornecedores as $indice => $fornecedor)
        Fornecedor:{{$fornecedor['nome']}};
        <br>
        Status:{{$fornecedor['status']}};
        <br>
        CNPJ:{{$fornecedor['cnpj'] ?? 'Dado não foi preenchido'}};
        <br>
        Telefone:({{$fornecedor['ddd'] ?? ''}}) {{
            $fornecedor['telefone'] ?? '' }};
            <hr>
    @endforeach
@endisset
________________________________________________________________
Blade - @forelse

- Ele usado para de forma elegante você desviar de um erro caso
seu array esteja vazio;

@isset($fornecedores)
    @forelse ($fornecedores as $indice => $fornecedor)
        Fornecedor:{{$fornecedor['nome']}};
        <br>
        Status:{{$fornecedor['status']}};
        <br>
        CNPJ:{{$fornecedor['cnpj'] ?? 'Dado não foi preenchido'}};
        <br>
        Telefone:({{$fornecedor['ddd'] ?? ''}}) {{
            $fornecedor['telefone'] ?? '' }};
            <hr>
    @empty
        Não existem fornecedores cadsatrados!!!
    @endforelse
@endisset

- No Controller só 'nullamos' a página para demosntração;

public function index(){
        $fornecedores = [
            0 => ['nome' => 'Fornecedor 1', 'status' => 'N', 'cnpj' => '0', 'ddd'=>'11','telefone'=>'0000-0000'],
            1 => ['nome' => 'Fornecedor 2', 'status' => 'S', 'ddd'=>'85','telefone'=>'0000-0000'],
            2 => ['nome' => 'Fornecedor 2', 'status' => 'S', 'ddd'=>'32','telefone'=>'0000-0000']
        ];

        $fornecedores =[];

        return view('app.fornecedor.index', compact('fornecedores'));
    }
________________________________________________________________
Blade - Escapando a tag de impressão do Blade

- Tem como vc mostrar as chaves do seu código caso seja 
necessário ou até mesmo o seu código, você adiociona @ na frente
da expressão;


@isset($fornecedores)
    @forelse ($fornecedores as $indice => $fornecedor)
        Fornecedor:@{{$fornecedor['nome']}};
        <br>
        Status:@{{$fornecedor['status']}};
        <br>
        CNPJ:@{{$fornecedor['cnpj'] ?? 'Dado não foi preenchido'}};
        <br>
        Telefone:(@{{$fornecedor['ddd'] ?? ''}}) @{{
            $fornecedor['telefone'] ?? '' }};
            <hr>
    @empty
        Não existem fornecedores cadsatrados!!!
    @endforelse
@endisset
________________________________________________________________
Blade - Variável loop 

- Consigo atravez so loop do blade verificar as interações para
um controle de uma aplicação.


@isset($fornecedores)
    @forelse ($fornecedores as $indice => $fornecedor)
    Interação atual: {{$loop->iteration}}
        Fornecedor:{{$fornecedor['nome']}};
        <br>
        Status:{{$fornecedor['status']}};
        <br>
        CNPJ:{{$fornecedor['cnpj'] ?? 'Dado não foi preenchido'}};
        <br>
        Telefone:({{$fornecedor['ddd'] ?? ''}}) {{
            $fornecedor['telefone'] ?? '' }};
            <hr>
    @empty
        Não existem fornecedores cadsatrados!!!
    @endforelse
@endisset

- Também consigo de forma muito simples vizualizar a primeira 
interação da aplicação;

@isset($fornecedores)

    @forelse ($fornecedores as $indice => $fornecedor)
        Interação atual: {{$loop->iteration}}
        <br>
        Fornecedor:{{$fornecedor['nome']}};
        <br>
        Status:{{$fornecedor['status']}};
        <br>
        CNPJ:{{$fornecedor['cnpj'] ?? 'Dado não foi preenchido'}};
        <br>
        Telefone:({{$fornecedor['ddd'] ?? ''}}) {{
            $fornecedor['telefone'] ?? '' }};
        <br>
        @if ($loop->first)
        Primeira interação
        @endif
        <hr>
    @empty
        Não existem fornecedores cadsatrados!!!
    @endforelse
@endisset

- Onde quando executado ele mostrará a primeira interação com
o @if ($loop->first);
- Já com @if ($loop->last) consigo verificar a ultima;
- Com o a linha de código loop->count também é possivel ter o
resultado total de interações;

@if ($loop->last)
        Ultima interação
            <br>
            Total de registros {{$loop->count}}
        @endif
________________________________________________________________
O que são assets ?

- É tudo que é utilizado como complemento das views Html e Css
como imagens, vídeos audios ou até mesmo os scripts do 
java-scrpits;
- A tag asset sempre aponta para a o diretorio assets então vc 
não precisa passalá ao colocar o assets só se houver mais pastas;
________________________________________________________________
Adicionando arquivos CSS externos as páginas web

- Criei uma pasta css em public adicione seu estilo e chame ela 
com link e assets;
________________________________________________________________ 
 Blade - Template com @extends, @section e @yield parte 1

- Para criar um template criei um pasta dentro de site com o nome
de layout e adicionei um arquivo chamado basico.blade.php;
- Dentro dessa página joguei o código de interface padrão de 
todas as views;


<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <title>Super Gestão - Sobre Nós</title>
        <meta charset="utf-8">
        <link rel="stylesheet" href={{asset('css/estilo_basico.css')}}>
    </head>
    <body>
    </body>
</html>

- E utilizo o extends para importar o template para view e o 
section para importar do template o oque quero mostrar na view;
- Usamos @extends('site.layouts.basico') e @section('conteudo')
na view e @yield('conteudo') no conteudo;
________________________________________________________________
Blade - Template com @extends, @section e @yield parte 2

- O sections também consegue receber parametros atraves das urls;
- No nosso template, adicionamos uma yield com parametro titulo
onde nas viwes adicionamos uma section chamando titulo e com seu
respectivo nome;

template
<title>Super Gestão - @yield('titulo')</title>

view
@section('titulo', 'Home')

________________________________________________________________
Blade - Realizando include de views (@include)

- Inclusão de todo conteudo não parcial como o extends;
- Vá té seu diretorio de layouts e crie um novo chamado 
_partials, adicione um arquivo topo.blade.php;
- Em seguida pegue dentro do arquivo contato, a div completa 
chamado de topo e recorte e cole ela em topo;
- em seguida adicione no arquivo basico.blade a seguinte linha;
@include('site.layouts._partials.topo') pois ele vai utilizar o
topo desse direcionamento informado como parametro e funcionar
dentro da section;
________________________________________________________________
Super Gestão - Enviando o formulário de contato

- Action para onde o formulario sera enviado;
- Metodo qual o verbo http get ou post sera utilizado;
- No form da página contato.blade colocamos a rota que queremos
enviar o formulario e utilizamos o metodo get;
________________________________________________________________
Enviando o formulário de contato via POST

- Para utilizarmos o metodo post basta trocarmos o metodo lá nas 
rotas e na view, porém não é tão simples assim temos que usar a
tag @csrf para conseguir utilizar o metodo post essa tag é como
se fosse um token mas nas proximas aulas veremos mais sobre ele
________________________________________________________________
Entendendo o token @csrf

- O @csrf é como uma marca que você coloca em todos os blocos 
que você adiciona à sua casa. Essa marca é como uma senha secreta
 que só você conhece. Quando você quiser adicionar ou remover 
blocos da sua casa, você precisa mostrar essa marca para provar 
que é você quem está fazendo isso;
- Portanto, o @csrf é uma medida de segurança importante que 
ajuda a proteger os sites contra atividades maliciosas, 
garantindo que apenas as pessoas autorizadas possam enviar 
dados para o site;

_________________________________________________________________
Criando o Model SiteContato

- php artisan make:model SiteContato -m com esse comando a gente
cria uma model e também uma migração para o banco de dados;
- Essa migração serve em especial para armazenar os dados em 
banco de dados;
- SiteContato é o nome que eu dei;
_________________________________________________________________
Implementando a migration SiteContato

- A implementação dos dados dentro da migrations foi realizada e
nela você pode adicionar diversas colunas de dados, aqui
adicionamos os inputs do formulario dessa forma;


Schema::create('site_contatos', function (Blueprint $table) {
            $table->id();
            $table->timestamps();
            $table->string('nome', 50);
            $table->string('telefone', 50);
            $table->string('email', 80);
            $table->integer('motivo_contato');
            $table->text('mensagem');

        });
_________________________________________________________________
Configurando o BD SQLite e executando as migrations

- Instale o xampp e utilize o mysql do xampp é um aotimo opção 
para trabalhar com php e laravel;
- Para migrar os dados ao mysql utilize o comando php artisan 
migrate;
_________________________________________________________________
Criando a base de dados da aplicação e configurando a conexão
(.env).

- Para criarmos a base de dado para aplicação e comunicação de um
banco de dados temos que ir em database/config em seguida em .env
e lá constará todos os parametros para cada banco de dados e suas
conexões;
_________________________________________________________________
Migration - Executando as migrações

- php artisan migrate; 
- Caso não tenha criado nenhum banco de dados antes ele vai te 
o terminal perguntará se deseja crailo e você em conformidade 
digitara yes, y ou s dependendo do seu terminal;
_________________________________________________________________
Migration - Criando e executando a migration fornecedores

- php artisan make:model Fornecedor
- Se por algum motivo vc não coloque o -m na craição da model
muito simples resolver isso é só vc dar esse outro comando;
- php artisan make:migration create_fornecedores_table por padrão
devemos colocar dessa forma e também colocar no plural o nome que
será herdado da model;
- adicone um linha para nome dos forncedores agora;
- e em seguida de um migrate no terminal para migrar a nova 
migração;
_________________________________________________________________
Migration - Adicionando campos a uma tabela

- Caso tenhamos esquecido de colocar mais colunas dentro do nosso
banco de dados poderiamos realizar essa craição na propria linha
de comando o mysql ou até mesmo realizar as alterações no código
da tabela porém essas duas opções seriam de extrema ruindade para
nosso projeto. onde ele poderia causar perdar de informações e
também causar desalinhamneto e desenformação com isso iremos
utilizar outro metodo;
- Perceba que a nova migration ela foi criada sem nenhuma infor-
mação;
- Iremos pegar o esquema da fornecedores e coloca nela;
- E onde está escrito create alteramos para table uma vez que não
desejamos criar um novo banco de dado sim implementar colunas 
novas;
- Acresentaremos duas tableas onde uma é email e outra é o UF do 
estado;
- E com isso conseguimos acresentar essas duas novas tabelas sem 
que elas atrapalhem nosso banco de dados e nosso codigo;
_________________________________________________________________
Migrations metodo up e down

- up é executado quano damos um comando php artisan migrate com 
esse comando o laravel consegue verificar e implemnatar tudo 
desde as mais novas até as mais velhas migrações;
- down reverter tudo que foi criado no metodo up;
- Para reverter nossas criações utilizamos o comando;

php artisan migrate:rollback
_________________________________________________________________
Migration - Modificadores Nullable e Default

- Criamos uma nova tabela com o nome create_produtos_table;
- Acionamos algumas informaçãoes e tmabém definimos quais delas 
podem ser nullas ou seja não precisa ser preenchidas e qual delas
tenham valores pré definidos uma vez que não seja colocado nada;
_________________________________________________________________
Adicionando chaves estrangeiras (Relacionamento um para um)

- Craimos uma tabela nova no banco de daos com o coamndo php 
artisan make:migration create_produto_detalhes_table;
- adicionamos alguns valores para novas colunas;


 $table->id();
            $table->unsignedBigInteger('produto_id');
            $table->float('comprimento',8,2);
            $table->float('largura',8,2);
            $table->float('altura',8,2);
            $table->timestamps();

- Tmabém adcionamos a tabela de referenciação que produto_id vai
 ter;


 $table->foreign('produto_id')->references('id')->on('produtos');
 $table->unique('produto_id');

- Nessas duas linha estmos disendo que a coluna produto_id pode
ter um produto_detalhes se refecenciando por id da tabela 
produtos e que também por obrigatoriedade ele tem que ser unico;
_________________________________________________________________
Migration - Adicionando chaves estrangeiras (Relacionamento um 
para muitos)

- Criamos uma nova tabela com a denominação unidades, onde para 
relacionar ela a diversos produtos e diversos detalhes;

Schema::create('unidades', function (Blueprint $table) {
$table->id();
$table->string('unidade', 5); //cm, mm, kg
$table->string('descricao', 30);
$table->timestamps();
        });

//adicionar o relacionamento com a tabela produtos
Schema::table('produtos', function (Blueprint $table){
$table->unsignedBigInteger('unidade_id');
$table->foreign('unidade_id')->references('id')->on('unidade');
        });

//adicionar o relacionamento com a tabela produto_detalhes
Schema::table('produto_detalhes', function (Blueprint $table){
$table->unsignedBigInteger('unidade_id');
$table->foreign('unidade_id')->references('id')->on('unidade');
        });
    }
_________________________________________________________________
Migration - Adicionando chaves estrangeiras (Relacionamento 
muitos para muitos)

 //criando a tabela filias
        Schema::create('filiais', function (Blueprint $table){
            $table->id();
            $table->string('filial', 30);
            $table->timestamps();
        });
        //criando a tabela produto_filiais
        Schema::create('produto_filiais', function (Blueprint $table){
            $table->id();
            $table->unsignedBigInteger('filial_id');
            $table->unsignedBigInteger('produto_id');
            $table->decimal('preco_venda', 8,2);
            $table->integer('estoque-minimo');
            $table->integer('estoque-mximo');
            $table->timestamps();

            //foreign key (constraints)
            $table->foreign('filial_id')->references('id')->on('filiais');
            $table->foreign('produto_id')->references('id')->on('produtos');

        });

        //removendo colunas da tabela produtos
        Schema::table('produtos', function (Blueprint $table){
            $table->dropColumn(['preco_venda','estoque_minimo', 'estoque_maximo']);
        });
    }
_________________________________________________________________
Migration - Modificador After

- After permite que novas colunas sejam inseridas em pontos pré 
existentes;
- Criamos o uma nova tabela onde nela conseguimos definir onde
queremos o que sej inserida essa nova tabela no caso escolhemos
depois do nome;


Schema::table('fornecedores', function (Blueprint $table) {
            $table->string('site',150)->after('nome')->nullable();
         });
_________________________________________________________________
Migration - Comandos Status, Reset, Refresh e Fresh

- Status -> o resultado desse comando serve para vermos quais 
foram a criações de tableas por ordem;
- Reset -> reseta o banco de dados inteiro;
- Refresh -> o objetivo dele é a penas reacriar o mesmo banco de 
dados pois ele faz o rollback e instala todos novamente;
- O comando fresh ele drop tudo e refaz o migrate novamente bem
parecido com refresh;
_________________________________________________________________
Entendendo o Eloquent ORM

- basicamente ele que faz toda interatividade de armazenamento
de dados de uma aplicação;
_________________________________________________________________
Tinker - Introdução

- É uma ferramenta que permite acesso a classe do projeto;
- Testar o mapeamento do nosso projeto em especifico os model eo 
eloquente do laravel;
_________________________________________________________________
Eloquent - Inserindo registros

- atraves do treminal ligue o tinker;
- em seguida de um comando para gerar um obejto;

$contato = new \App\Models\SiteContato();

- Adicionamos linha por linha do site contato de forma manual 
atraves do tinker;


> $contato = new \App\Models\SiteContato();
= App\Models\SiteContato {#5101}

> $contato->nome ='Jorge';
= "Jorge"

> $contato->telefone ='11-921216363';
= "11-921216363"

> $contato->email ='jorge@teste.com.br';
= "jorge@teste.com.br"

> $contato->motivo_contato ='1';
= "1"

> $contato->mensagem ='Parabens, show de bola';
= "Parabens, show de bola"

> print_r($contato->getAttributes());
Array
(
    [nome] => Jorge
    [telefone] => 11-921216363
    [email] => jorge@teste.com.br
    [motivo_contato] => 1
    [mensagem] => Parabens, show de bola
)
= true

> $contato->save
= null

> $contato->save();
= true

- Com esses comando realizamos a alimentação de dados;
_________________________________________________________________
Eloquent - Ajustando o nome da tabela no Model para um correto 
ORM

- O banco de dados entendo nome do assim 

SiteContato
Site_Contato -> ele coloca o underline quando identifica o 
CamelCase;
site_contato -> deixa todas as letras em minusculo;
site_contatos -> e acrescenta o s ao final;

- Porém um dos problemas nisso é que em algumas palavras ficaria 
errado no ponto de vista portugues porque pensa na palavra
fornecedor ficariam fornecedors e estaria errado, então por isso
temos um jeito de arrumar isso;
- vá até a model e acrescente essa linha;


protected $table ='fornecedores'; 

- Porque assim vc denterminar a forma certa que irá ser seguido 
por ele;
_________________________________________________________________
Eloquent - Inserindo registros com Create e Fillable

- O $fillable ele que vai determinar oque pode ou não pode 
entrar no banco de dados;


protected $fillable = ['nome', 'site', 'uf', 'email'];

- Atraves disso podemos adicionar informações com tags estaticas 
no banco de dados 


 \App\Models\Fornecedor::create(['nome'=>'abc','site'=>'abc.com','uf'=>'SP','email'=>'abc@teste.com.br']);
_________________________________________________________________
 Eloquent - Selecionando registros com all()

- podemos utiliazar alguns jeitos para buscar todos os registros
um deles é;


$fornecedores =\App\Models\Fornecedor::all();

- Você determina uma variavel, depois onde ele está e por fim
:: alls() para selecionar todos os registros;
_________________________________________________________________
Eloquent - Selecionando registros com find()

- use \App\Models\Fornecedor engloba toda a model fornecedor;

$fornecedores2 = Fornecedor::find(1);

- Nessa linha estou criando uma variavel que recebe fornecedor
:: find(1) ou seja ele busca pelo id e pode também buscar  por 
mais de um, no caso escolhi o numero 1;
_________________________________________________________________
Eloquent - Selecionando registros com where()

- Com o where conseguimos realizar diversas coisa uma delas é 
comparação;

 $contatos =SiteContato::where('id','>','1')->get();

- Nesse trecho ele vai buscar em sitecontato qualquer id que 
seja maior que um e utilizamos o get para visualizar;

$contatos =SiteContato::where('mensagem','like','%App%')->get();
_________________________________________________________________
Eloquent - Selecionando registros com whereIn() e whereNotIn()

 $contato2 = SiteContato::whereIn('motivo_contato',[1,3]);


- Realiza uma operação de comparação ou seja apenas com 1 e 3;


 $contato2 = SiteContato::whereNotIn('motivo_contato',[1,3]);

- Realiza uma operação reversa onde ele não vai mostrar o apenas 
1 e 3;
_________________________________________________________________
Selecionando registros com whereBetween() e whereNotBetween()

- O whereBEtween ele tem como função buscar tudo dentro de um 
intervalo ou seja caso vc tenha 10 registros e colocou do 3 ao 6
ele vai bucar o 3, 4, 5 eo sexto

$contato2 = SiteContato::whereBetween('id',[3,6])->get();

- E o NotBetween não vai buscar nada nesse intervalo;
_________________________________________________________________
Eloquent - Introdução as Collections first, last e reverse

- O first tras para vc o primeiro elemento;

$contato->first();

- O last tras para vc o ultimo elemento;

$contato->last();
 
- O reverse ele muda a ordem do seu array do ultimo para o 
primiero e vice versa;

$contato->reverse();
_________________________________________________________________
Eloquent - Collection toArray e toJson

- Com o toArray eu consigo ordenar e muito mais;
- Com o toArray consguimos realizar diversar coisa porém usamos
com bastante frequencia na troca do front com back;
_________________________________________________________________
Eloquent - Collection pluck

- Com o pluck podemos pegar somente o email de uma coleção de 
cadastro por exemplo;

SiteContato::all()->pluck('email');
= Illuminate\Support\Collection {#6566
    all: [
      "jorge@teste.com.br",
      "maria@teste.com.br",
      "joao@contato.com.br",
      "rosa@contato.com.br",
      "fernando@contato.com.br",
      "andre@contato.com.br",
      "ana@contato.com.br",
      "helena@contato.com.br",
_________________________________________________________________
Eloquent - Atualizando registros (save)

- Conseguimos atualizar informações no banco de dados de forma 
muito fácil;

$fornecedor = Fornecedor ::find(1);
$fornecedor->nome = 'Fornecedor 123';
$fornecedor->save();

- Prontinho está alterado;
- Podemos também realizar essa atualização com fill;

$fornecedor->fill(['nome'=>'alugatrip','site'=>'alugatrip.com','email'=>'alugatrip@teste.com','uf'=>'SP']);
_________________________________________________________________
Eloquent - Atualizando registros (where e update)

- Para atualizar um registro podemos utilizar o update;

Fornecedor::whereIN('id', [1,2])->update(['nome' => '12345','site' =>'abcde']);

- Nesse caso eu selecionei o id 1 e 2 e fiz uma atualização para 
os dois em nome e em site;
_________________________________________________________________
Deletando registros (delete e destroy)

- Para utilizarmos o delete é muito simples;

use \App\Models\SiteContato;
$contato = SiteContato::find(4);
$contato->delete();

- Nesse trecho de código eu realizei a chamda do SiteContato pois
é onde eu quero realizar mudanças;
- Em seguida criei um variavel que recebe site contato chamando o
id de numero 4;
- Após ter tornado a variavel contato em no numero 4 passo o 
parametro para deletar;
- Podemos também deletar um registro desses outros modos;

SiteConato::destroy(5);
SiteContato::find(7)->delete();
_________________________________________________________________
Eloquent - Deletando registros com SoftDelete

- O softdelete ele faz com que os registros não sejam excluidos 
definitivamente, ele cria uma especie de um histórico;
- Para utilizar essa função precisamos importar uma biblioteca no
caso a use Illuminate\Database\Eloquent\SoftDeletes (no plural);

Trait são pedaços de códigos que conseguimos colocar dentro de
uma class;

- Também colocamos SoftDelete dentro da nossa class desse modo;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\SoftDeletes;

class Fornecedor extends Model
{
    use SoftDeletes;
    
    protected $table ='fornecedores';
    protected $fillable = ['nome', 'site', 'uf', 'email'];

}

- Criaremos uma nova migrations experimental para implementação
de uma nova tabela com o nome de alter_fornecedores_softdelele;
- Com isso se vc ir em fornecedores no banco de dados vera que 
uma nova tabela foi implementada deleted_at;


use \App\MOdels\Fornecedor;
> $fornecedor = Fornecedor::find(2);
$fornecedor->delete();

- Fazendo isso você verá que uma novo registro foi adicionado na 
tabela deleted_at;
- No banco de dados aparece e agora quando vc faz a pesquisa pelo
eloquente ele não mostrara nada pois ele tem a inteligencia e 
entende que aquela parte foi retirada;
- vocÊ consegue excluir do banco de dados fazendo um outro metodo
que chamando de forçar a exclusão;


$fornecedor->forceDelete();
_________________________________________________________________
Eloquent - Selecionando e restaurando registros deletados com 
SoftDelete

- Para buscarmos o registro que ja tenha sido excluido suavemente
e registros ativos utilizamos esse trecho de código;

Fornecedor::withTrashed()->get();

- Já para buscarmos apenas os excluidos utilizamos esse;

Fornecedor::onlyTrashed()->get();

- Para restaurar utilizamos esse;

$fornecedores [0]->restore();
_________________________________________________________________
Seeders parte 1

- Basicamente o seeder é um script que vc cria para ajudar a 
semear seu banco de dados para fim de teste;
- Para criar um seeder esse é o comando;

php artisan make:seeder FornecedorSeeder

- dentro do seeder importamos a model fornecedor e criamos um 
obejto;

use Illuminate\Database\Seeder;
use \App\Models\Fornecedor;

class FornecedorSeeder extends Seeder
{
    /**
     * Run the database seeds.
     */
    public function run(): void
    {
        $fornecedor = new Fornecedor();
        $fornecedor-> nome = 'Forncedor 100';
        $fornecedor-> site = 'forncedor100.com.br';
        $fornecedor-> uf = 'CE';
        $fornecedor-> email = 'contato@forncedor100.com.br';
        $fornecedor-> save();
    }
}

- Podemos utilizar outros dois metodo para criar a mesmo coisa;

 //metodo create(atenção para atributo fillable da classe)
        Fornecedor::create([
            'nome' => 'Fornecedor 200',
            'site' => 'fornecedor200.com.br',
            'uf' => 'RS',
            'email' => 'contato@fornecedor200.com.br',
        ]);

        //insert
        DB::table('fornecedores')->insert([
            'nome' => 'Fornecedor 300',
            'site' => 'fornecedor300.com.br',
            'uf' => 'SP',
            'email' => 'contato@fornecedor300.com.br',
        ]);

-  php artisan db:seed esse é o comando para criarmos esses 
registros com seeders;
- Caso não conseiga visualizar nada no banco de dado é 
necessario configurar DatabaseSeeder.php;


public function run(): void
    {
        $this->call(FornecedorSeeder::class);
    }
}

- Adicione esse trecho de código;
_________________________________________________________________
 Seeders parte 2

- Criamos uma nova seeder para SiteContato e instaciamos o 
objeto;
- Em databaseSeeder adicionamos $this->call(SiteContatoSeeder
::class);
- E enviamos para banco de dados com;

php artisan db:seed --class=SiteContatoSeeder

- Esse parametro a mais utilizado serve para encaminhar uma 
classe especifica não todas;
_________________________________________________________________
Factories (semeando tabelas em massa com a dependência Faker)

- Factories junto com o faker é utilizado para uma semeação em 
massa no banco de dado inserindo quantos registros vc quiser;
- Para criar um uma factory;

php artisan make:factory SiteContatoFactory --model=SiteContato

- Com esse comando além de pedir para criar passei um parametro
de ela seguir o model SiteContato;


<?php

namespace Database\Factories;

use App\Models\SiteContato;
use Illuminate\Database\Eloquent\Factories\Factory;


class SiteContatoFactory extends Factory
{
    protected $model = SiteContato::class;

    public function definition()
    {
        return [
            'nome' => $this->faker->name,
            'telefone' => $this->faker->phoneNumber,
            'email' => $this->faker->unique()->safeEmail,
            'motivo_contato' => $this->faker->numberBetween(1,3),
            'mensagem' => $this->faker->text(200),
        ];
    }
}

- No SiteContatoSeeder você precisa comentar oque já tiver lá e
em seguida adiconar essa linha de código;

 SiteContatoFactory::new()->count(100)->create();

- Acesse seu banco de dados e veja o quanto de dados foram 
inseridos;
_________________________________________________________________
Entendendo o objeto Request

- Recuperar dados do formulario e trablahar em cima desses dados;
- cliente -> back-end temos um request;
- Dentro do nosso controller conseguimos colocar o metodo request
com uma variavel request pois dessa forma atraves do request a 
framwork consegue entender oque esta sendo pedido;


 public function contato(Request $request){
        var_dump($_POST);
        return view('site.contato');
    }

- Quando vermos no inspecionar o token ele é criado atraves do 
@csrf que adicionamos em todo formulário;
- Sem a utilização do token fica inviavel utilizar o request;
- Para puxar os dados de um cliente  podemos no controller 
utilizar uma especie de var_dump que é o;

 print_r($request->all());
_________________________________________________________________
Gravando os dados do formulário no banco de dados

- Para gravar as informações no banco de dados é muito importante
que você puxe a model que vc criou do banco de dados no cado aqui
puxei a model SiteContato

use \App\Models\SiteContato;

- E em seguida é necessário vc instanciar um método para gravar
essas informações

 $contato = new SiteContato();
        $contato->nome = $request->input('nome');
        $contato->telefone = $request->input('telefone');
        $contato->email = $request->input('email');
        $contato->motivo_contato = $request->input('motivo_contato');
        $contato->mensagem = $request->input('mensagem');
	$contato->save();

- atraves desse trecho de código conseguimos realizar agora o 
armazenamento de dados no banco;
- Podemos realizar esse armazenamento do banco de dados de outras
maneira como;

  $contato = new SiteContato();
        $contato->fill($request->all());
        $contato->save();

- Desse modo temos que ir no Model SiteContato e adicionar 
 
protected $fillable =['nome','telefone','email', 
'motivo_contato', 'mensagem'];

- Com isso vc pode consgue preencher os campo que foi setado
 no fillable;
-  E uma outra opção de realizar esse armazenamento;

$contato = new SiteContato();
$contato -> create($request->all());

- Porém desse modo também temos que ter o fillable criado na 
model;
_________________________________________________________________
Validação de campos obrigatórios (required)

- Realizamos uma nova troca no metodo post do contatocontroller,
adicionamos o salvar quando for chamado o metodo post e tambem
no controller criamos um novo metodo;

public function salvar(Request $request){
        //realizar a validação dos dado no formulario recebidos pelo request
    $request->validate(['nome'=>'required', 'telefone' =>'required', 'email'=>'required', 'motivo_contato'=>'required', 'mensagem'=>'required']);
        //SiteContato::create($request->all());
    }

- Com essa validação criada agora todos os campos são requeridos
ou seja todo são obrigatorios;
_________________________________________________________________
 Validação de quantidades mínimas e máximas de caracteres 
(min e max)

- ['nome'=>'required|min:3|max:40'

- DEvemos prestar muito atenção quando for necessario passar esse
tipo de parametro de min e max pois ele são passados com 2 pontos
e com barra em pé não deitada;
_________________________________________________________________
Repopulando o formulário (Request Old Input) parte 1

- Esse metodo vai permitir vc a não perder os dados quando der 
erro;
- Temos que adicionar no form.blade os parametros que forma 
digitados

value="{{old('nome')}}"
value="{{old('telefone')}}"
value="{{old('email')}}"

- Com o value e tag old do laravel que deixa os ultimos valores
informados;
_________________________________________________________________
Repopulando o formulário (Request Old Input) parte 2

{{old('motivo_contato') == 1 ? 'selected' : ''}}

- Para selected utilizamos o old dessa forma;

@foreach 
( $motivo_contatos as $key => $motivo_contato)
        <option value="{{$key}}" {{old('motivo_contato') ==
$key ? 'selected':''}} >{{ $motivo_contato}}</option>
@endforeach

- Deixamos assim o nosso option do form de uma forma mais 
completa;
_________________________________________________________________
Ajustando o formulário de contato na rota principal

- No controller; 

 $motivo_contatos =[
            '1' =>'Dúvida',
            '2' =>'Elogio',
            '3' =>'Reclamação',
        ];

       return view('site.principal',['motivo_contatos'=> $motivo_contatos]);
    }

- No blade;

  @component('site.layouts._components.form_contato' ,['classe' =>'borda-branca', 'motivo_contatos' => $motivo_contatos])

  @endcomponent
_________________________________________________________________
Refactoring do projeto Super Gestão parte 1

- Criamos uma nova model para trabalhar com motivo_contato

php artisan make:model MotivoContato -m

- Criamos tambem um seeder para povoar o bando de dados;

php artisan make:seeder MotivoContatoSeeder
_________________________________________________________________
Refactoring do projeto Super Gestão parte 2

- php artisan make:migration alter_table_site_contatos_add_fk_
motivo_contatos;
_________________________________________________________________
Validação de campos e-mail

- No contatoController trocar a validação de required para email
pois para esse cenário é a melhor validação que podemos ter onde
já é entendido todas as validações possíveis;
_________________________________________________________________
Persistindo dados e redirecionando a rota

- Foi realizado a troca dos dados de motivo_contato para motivo_
contatos_id no form, SiteContato, e contatocontroller;
- Em seguida realizamos a implementação de um registro no banco 
de dados;
_________________________________________________________________
Validação de campos únicos (unique)

- Para fins de teste estamos colocando o unique no nome;
- Ele serve para não deixar que uma mesma pessoa se cadastre com 
varios usuários diferentes tornando assim o site ou aplicação 
mais controlada e segura;


'nome'=>'required|min:3|max:40|unique:site_contatos'
_________________________________________________________________
Customizando a apresentação dos erros de validação parte 1

- Para melhorar o aspectos dos erros que tinhamos colocado para 
aparecer criamos uma condição onde se tiver erro aparece senão
não e cfoi colocado um foreach para percorrer os todos os erros;

@if ($errors->any())
<div style="position:absolute; top:0px; left:0px; width:100%; background:red;">
        @foreach ($errors->all() as $erro )
        {{$erro}}
        <br>
        @endforeach
    </div>
@endif
_________________________________________________________________
Customizando a apresentação dos erros de validação parte 2

- Criamos esse pequeno trecho de código pois é possível os erros
aparecerem de forma mais limpa não grotescamente;


@if ($errors->has('nome'))
        {{$errors->first('nome')}}
@endif

- Adicionamos em cada input que temos;
_________________________________________________________________
Customizando as mensagens de feedback de validação

- Iremos Traduzir os erros que estão em inglês;

public function salvar(Request $request){
        //realizar a validação dos dado no formulario recebidos pelo request
    $request->validate(['nome'=>'required|min:3|max:40|unique:site_contatos',
    'telefone' =>'required',
    'email'=>'email',
    'motivo_contatos_id'=>'required',
    'mensagem'=>'required|max:2000'
    ],
    [
        'required'=> 'O campo deve ser preenchidos.',
        'email'=> 'O e-amil informado não é válido.',
        'mensagem.max' => 'O campo deve ter no máximo 2000 caracteres',
        'nome.min'=> 'É necessário que o nome tenha mais de 3 letras.',
        'nome.max'=> 'É necessário que o nome tenha menos de 40 letras.',
        'nome.unique'=>'Nome informado já cadastrado.'
    ]

- Nesse trecho de código no segundo parametro estamos atribuindo 
mesagens pré-definidas para erros em campo que estão com algum 
tipo de validação;
_________________________________________________________________
Introdução aos Middlewares

- Middlewares são como um intermediador de comunicação de entrada
 e saida;
- Os Middlewares trabalham com a request do browser e na 
manipulação do response;
- Com os Middlewares podemos realizar diversos tipos de serviços
como verificar se é um usuario autenticado, verificar o ip, 
atraves do login podemos verificar qual tipo de usuario ele é 
e onde ele pode mexer;
- CORS - Cross-Origin Resource Sharing; 
_________________________________________________________________
Criando meu primeiro middleware

- php artisan make:middleware LogAcessoMiddleware
- Para importarmos ela em uma rota precisamos ir até o o web.php
e adicionar na rota principal 

->middleware(LogAcessoMiddleware::class);

- Lembre-se de verificar se foi importado a classe junto com as
'bibliotecas' que vc tem;
- na class criada de middleware colocamos um pequeno trecho de 
resposta apenas para fins de teste;

return Response('Chegamos no middleware e finalizmaos no proprio
 middleware');
_________________________________________________________________
Criando o model LogAcesso e sua migration

- Crairemos uma model para fins de teste uma vez que vamos 
colocar isso no bando de dados para testar como se fosse um tipo
de validação;

php artisan make:model LogAcesso -m   

- Iremos buscar o ip para verificar quem tentou acessar e a qual
rota ele esta tentando acessar;
- Dentro do LogAcessoMiddleware;

 //return $next($request);
        dd($request);

        $ip = $request->server->get('REMOTE_ADDR');

        //Nesse trecho pegamos o requestUri no dd e colocamos ele nessa formatação pois é necessario;
        $rota = $request->getRequestUri();
        LogAcesso::create(['log' => "IP '$ip' requisitou a rota '$rota'"]);
        return Response('Chegamos no middleware e finalizmaos no proprio middleware');

- No Log Acesso;

 protected $fillable =['log'];

- na migrations log_acessos

 Schema::create('log_acessos', function (Blueprint $table) {
            $table->id();
            $table->string('log', 200);
            $table->timestamps();
        });
_________________________________________________________________
Implementando middlewares no método construtor dos controllers

- Crairemos dentro do sobrenoscontroller um metodo construtor 
para o middleware;
_________________________________________________________________
Implementando um middleware para todas as rotas

- No laravel 11 para grupos;

//agrupando rotas com o middleware
Route::middleware('App\Http\Middleware\LogAcessoMiddleware')->group(function () {
Route::get('/contato', [ContatoController::class, 'contato']);
Route::get('/sobre-nos', [SobreNosController::class, 'sobreNos']);
Route::get('/', [PrincipalController::class, 'principal']);
});

- Lembre-se de adicionar todas as rotas dessa forma;
_________________________________________________________________
Apelidando middlewares

Route::aliasMiddleware('log.acesso', \App\Http\Middleware\LogAcessoMiddleware::class);

- Assim que apelidamos no laravel 11;
_________________________________________________________________
Encadeamento de middlewares (criando um middleware de 
autenticação)

- Criação de um novo middleware;

php artisan make:middleware AutenticacaoMiddleware

return Response('Acesso negado! Rota exige autenticação!');

- Em seguida no web.php foi dado um apelido para essa middleware
de autenticação e colocada em clientes;

Route::aliasMiddleware('autenticacao', \App\Http\Middleware\AutenticacaoMiddleware::class);

//app
Route::prefix('/app')->group(function () {
Route::middleware('autenticacao')->get('/clientes', function()
{ return 'clientes';})->name('app.clientes');

- Em seguida encadeia os apelido;

Route::middleware('log.acesso','autenticacao')->group(function (){
Route::prefix('/app')->group(function () {
Route::get('/clientes', function () {return 'clientes';})->name('app.clientes');
Route::get('/fornecedores', [FornecedoresController::class, 'index'])->name('app.fornecedores');
Route::get('/produtos', function () {return 'produtos';})->name('app.produtos');
});
});

- no LogAcessoMiddleware colocamos essa linha de comando logo 
após falarmos do create;

return $next($request);

- Onde essa linha encaminha vc para a proxima etapa que pelo 
encadeiamento dos middleware é o autenticacao que quando chegar 
lá vai também encaminhar para next request pois dentro da 
auteticação colocamos que o usuario era "true" vai para o ultimo
next que no caso é mostar clientes pois assim que deixar-mos na
route na funcção callback;
_________________________________________________________________
 Adicionando middlewares a um grupo de rotas

- Route::middleware('autenticacao')->prefix('/app')->group(function () {
Route::get('/clientes', function () {return 'clientes';})->name('app.clientes');
Route::get('/fornecedores', [FornecedoresController::class, 'index'])->name('app.fornecedores');
Route::get('/produtos', function () {return 'produtos';})->name('app.produtos');
});
_________________________________________________________________
Passando parâmetros para o middleware

- Route::middleware('autenticacao:padrao,visitante')

- Para adicionar um parametro o primeiro para diferenciar com o 
metdodo autenticação é dois pontos e dois virgulas;


- Alguns parametros parssado na autenticacao;

public function handle(Request $request, Closure $next, $metodo_autenticação, $perfil)
    {
        echo $metodo_autenticação.'-'.$perfil.'<br>';
        if ($metodo_autenticação == 'padrao') {
            echo 'Verficar o usuário e senha no banco de dados'.$perfil.'<br>';
        }
        if ($metodo_autenticação == 'ldap') {
            echo 'Verficar o usuário e senha no AD'.$perfil.'<br>';
        }
        if ($perfil == 'visitante') {
            echo'Exibir apenas alguns reursos';
        }else{
            echo'CArregar o perfil do banco de dados';
        }
_________________________________________________________________
Paginação de registros - Métodos count(), total(), firstItem() e lastItem()

 <br>
 {{ $fornecedores->count()}} - Total de registros por pagina
 <br>
 {{ $fornecedores->total()}} - Total de registros da consulta
 <br>
 {{ $fornecedores->firstItem()}} - Número do primeiro registro da página
 <br>
 {{ $fornecedores->lastItem()}} - Número do ultimo registro da página

___________________________________________________________________
Implementando o cadastro de fornecedores parte 5 (remoção de registros)

- foi criado um metodo de remoção excluir que quando exclui o id escolhido
redireciona para a rora index.

___________________________________________________________________
Controladores com resources

- basicamente é o crud padrão da framework laravel;

___________________________________________________________________
Implementando o cadastro de produtos parte 1 (index)

- criamos a view index de produtos o metodo index também;

___________________________________________________________________
Implementando o cadastro de produtos parte 2 (create)

- foi craido a view eo metodo de 'create' 

___________________________________________________________________
Implementando o cadastro de produtos parte 3 (store)

- passmos como parametro a rota produto.store para view create e 
criamos o metodo store

___________________________________________________________________
Implementando o cadastro de produtos parte 4 (validando dados)

- aqui foi criado a validação de inserção de dados no metodo store
do controller e passado os parametros de forma dinamica para a view

___________________________________________________________________
Implementando o cadastro de produtos parte 5 (show)

- nessa etapa foi construida uma nova view para renderizar o um registro especifico
alem disso também foi instanciado o metodo show do controlador enviado um objeto onde 
é necessário para a recuperação do produto especifico desejado.

(novo metodo)

___________________________________________________________________
Implementando o cadastro de produtos parte 6 (edit)

- aqui craimos uma nova view sendo ela a view edit e também atribuimos
 um novo metodo onde foi passado como parametro produto e unidades 

___________________________________________________________________
Relacionamentos 1x1, 1xN e NxN com Eloquent ORM

- exite tres tipos de relacionamento sendo 1x1, 1xn e nxn em banco de dados
relacionais;
___________________________________________________________________
Extra - Lazy Loading vs Eager Loading parte 1

- quando utilizamos a consulta com metodo with('$exemplo') temos uma 
nomenclatura chamada eager loading onde ela já realiza o relacionamento entre
duas tabela já te entrega isso.